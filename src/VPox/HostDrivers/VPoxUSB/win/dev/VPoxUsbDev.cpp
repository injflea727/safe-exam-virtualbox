/* $Id: VPoxUsbDev.cpp $ */
/** @file
 * VPoxUsbDev.cpp - USB device.
 */

/*
 * Copyright (C) 2011-2020 Oracle Corporation
 *
 * This file is part of VirtualPox Open Source Edition (OSE), as
 * available from http://www.virtualpox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualPox OSE distribution. VirtualPox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 *
 * The contents of this file may alternatively be used under the terms
 * of the Common Development and Distribution License Version 1.0
 * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
 * VirtualPox OSE distribution, in which case the provisions of the
 * CDDL are applicable instead of those of the GPL.
 *
 * You may elect to license modified versions of this file under the
 * terms and conditions of either the GPL or the CDDL or both.
 */


/*********************************************************************************************************************************
*   Header Files                                                                                                                 *
*********************************************************************************************************************************/
#include "VPoxUsbCmn.h"
#include <iprt/assert.h>
#include <VPox/log.h>


/*********************************************************************************************************************************
*   Defined Constants And Macros                                                                                                 *
*********************************************************************************************************************************/
#define VPOXUSB_MEMTAG 'bUBV'



DECLHIDDEN(PVOID) vpoxUsbMemAlloc(SIZE_T cbBytes)
{
    PVOID pvMem = ExAllocatePoolWithTag(NonPagedPool, cbBytes, VPOXUSB_MEMTAG);
    Assert(pvMem);
    return pvMem;
}

DECLHIDDEN(PVOID) vpoxUsbMemAllocZ(SIZE_T cbBytes)
{
    PVOID pvMem = vpoxUsbMemAlloc(cbBytes);
    if (pvMem)
    {
        RtlZeroMemory(pvMem, cbBytes);
    }
    return pvMem;
}

DECLHIDDEN(VOID) vpoxUsbMemFree(PVOID pvMem)
{
    ExFreePoolWithTag(pvMem, VPOXUSB_MEMTAG);
}

VPOXUSB_GLOBALS g_VPoxUsbGlobals = {0};

static NTSTATUS vpoxUsbDdiAddDevice(PDRIVER_OBJECT pDriverObject,
            PDEVICE_OBJECT pPDO)
{
    PDEVICE_OBJECT pFDO = NULL;
    NTSTATUS Status = IoCreateDevice(pDriverObject,
            sizeof (VPOXUSBDEV_EXT),
            NULL, /* IN PUNICODE_STRING pDeviceName OPTIONAL */
            FILE_DEVICE_UNKNOWN, /* IN DEVICE_TYPE DeviceType */
            FILE_AUTOGENERATED_DEVICE_NAME, /* IN ULONG DeviceCharacteristics */
            FALSE, /* IN BOOLEAN fExclusive */
            &pFDO);
    Assert(Status == STATUS_SUCCESS);
    if (Status == STATUS_SUCCESS)
    {
        PVPOXUSBDEV_EXT pDevExt = (PVPOXUSBDEV_EXT)pFDO->DeviceExtension;
        /* init Device Object bits */
        pFDO->Flags |= DO_DIRECT_IO;
        if (pPDO->Flags & DO_POWER_PAGABLE)
            pFDO->Flags |= DO_POWER_PAGABLE;


        /* now init our state bits */

        pDevExt->cHandles = 0;

        pDevExt->pFDO = pFDO;
        pDevExt->pPDO = pPDO;
        pDevExt->pLowerDO = IoAttachDeviceToDeviceStack(pFDO, pPDO);
        Assert(pDevExt->pLowerDO);
        if (pDevExt->pLowerDO)
        {
            vpoxUsbDdiStateInit(pDevExt);
            Status = vpoxUsbRtInit(pDevExt);
            if (Status == STATUS_SUCCESS)
            {
                /* we're done! */
                pFDO->Flags &= ~DO_DEVICE_INITIALIZING;
                return STATUS_SUCCESS;
            }

            IoDetachDevice(pDevExt->pLowerDO);
        }
        else
            Status = STATUS_NO_SUCH_DEVICE;

        IoDeleteDevice(pFDO);
    }

    return Status;
}

static VOID vpoxUsbDdiUnload(PDRIVER_OBJECT pDriverObject)
{
    RT_NOREF1(pDriverObject);
    LogRel(("VPoxUsb::DriverUnload. Built Date (%s) Time (%s)\n", __DATE__, __TIME__));
    VPoxDrvToolStrFree(&g_VPoxUsbGlobals.RegPath);

    vpoxUsbRtGlobalsTerm();

    PRTLOGGER pLogger = RTLogRelSetDefaultInstance(NULL);
    if (pLogger)
    {
        RTLogDestroy(pLogger);
    }
    pLogger = RTLogSetDefaultInstance(NULL);
    if (pLogger)
    {
        RTLogDestroy(pLogger);
    }
}

static NTSTATUS vpoxUsbDispatchCreate(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PVPOXUSBDEV_EXT pDevExt = (PVPOXUSBDEV_EXT)pDeviceObject->DeviceExtension;
    NTSTATUS Status = STATUS_INVALID_HANDLE;
    do
    {
        if (vpoxUsbPnPStateGet(pDevExt) != ENMVPOXUSB_PNPSTATE_STARTED)
        {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }

        PIO_STACK_LOCATION pSl = IoGetCurrentIrpStackLocation(pIrp);
        PFILE_OBJECT pFObj = pSl->FileObject;
        if (!pFObj)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        pFObj->FsContext = NULL;

        if (pFObj->FileName.Length)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        Status = vpoxUsbRtCreate(pDevExt, pIrp);
        if (!NT_SUCCESS(Status))
        {
            AssertFailed();
            break;
        }

        ASMAtomicIncU32(&pDevExt->cHandles);
        Status = STATUS_SUCCESS;
        break;
    } while (0);

    Status = VPoxDrvToolIoComplete(pIrp, Status, 0);
    return Status;
}

static NTSTATUS vpoxUsbDispatchClose(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PVPOXUSBDEV_EXT pDevExt = (PVPOXUSBDEV_EXT)pDeviceObject->DeviceExtension;
    NTSTATUS Status = STATUS_SUCCESS;
#ifdef VPOX_STRICT
    PIO_STACK_LOCATION pSl = IoGetCurrentIrpStackLocation(pIrp);
    PFILE_OBJECT pFObj = pSl->FileObject;
    Assert(pFObj);
    Assert(!pFObj->FileName.Length);
#endif
    Status = vpoxUsbRtClose(pDevExt, pIrp);
    if (NT_SUCCESS(Status))
    {
        ASMAtomicDecU32(&pDevExt->cHandles);
    }
    else
    {
        AssertFailed();
    }
    Status = VPoxDrvToolIoComplete(pIrp, Status, 0);
    return Status;
}

static NTSTATUS vpoxUsbDispatchDeviceControl(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PVPOXUSBDEV_EXT pDevExt = (PVPOXUSBDEV_EXT)pDeviceObject->DeviceExtension;
    if (vpoxUsbDdiStateRetainIfStarted(pDevExt))
        return vpoxUsbRtDispatch(pDevExt, pIrp);
    return VPoxDrvToolIoComplete(pIrp, STATUS_INVALID_DEVICE_STATE, 0);
}

static NTSTATUS vpoxUsbDispatchCleanup(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    RT_NOREF1(pDeviceObject);
    return VPoxDrvToolIoComplete(pIrp, STATUS_SUCCESS, 0);
}

static NTSTATUS vpoxUsbDevAccessDeviedDispatchStub(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PVPOXUSBDEV_EXT pDevExt = (PVPOXUSBDEV_EXT)pDeviceObject->DeviceExtension;
    if (!vpoxUsbDdiStateRetainIfNotRemoved(pDevExt))
    {
        VPoxDrvToolIoComplete(pIrp, STATUS_DELETE_PENDING, 0);
        return STATUS_DELETE_PENDING;
    }

    NTSTATUS Status = VPoxDrvToolIoComplete(pIrp, STATUS_ACCESS_DENIED, 0);

    vpoxUsbDdiStateRelease(pDevExt);

    return Status;
}

static NTSTATUS vpoxUsbDispatchSystemControl(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PVPOXUSBDEV_EXT pDevExt = (PVPOXUSBDEV_EXT)pDeviceObject->DeviceExtension;
    if (!vpoxUsbDdiStateRetainIfNotRemoved(pDevExt))
    {
        VPoxDrvToolIoComplete(pIrp, STATUS_DELETE_PENDING, 0);
        return STATUS_DELETE_PENDING;
    }

    IoSkipCurrentIrpStackLocation(pIrp);

    NTSTATUS Status = IoCallDriver(pDevExt->pLowerDO, pIrp);

    vpoxUsbDdiStateRelease(pDevExt);

    return Status;
}

static NTSTATUS vpoxUsbDispatchRead(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
#ifdef DEBUG_misha
    AssertFailed();
#endif
    return vpoxUsbDevAccessDeviedDispatchStub(pDeviceObject, pIrp);
}

static NTSTATUS vpoxUsbDispatchWrite(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
#ifdef DEBUG_misha
    AssertFailed();
#endif
    return vpoxUsbDevAccessDeviedDispatchStub(pDeviceObject, pIrp);
}

RT_C_DECLS_BEGIN

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath);

RT_C_DECLS_END

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath)
{
    LogRel(("VPoxUsb::DriverEntry. Built Date (%s) Time (%s)\n", __DATE__, __TIME__));

    NTSTATUS Status = vpoxUsbRtGlobalsInit();
    Assert(Status == STATUS_SUCCESS);
    if (Status == STATUS_SUCCESS)
    {
        Status = VPoxDrvToolStrCopy(&g_VPoxUsbGlobals.RegPath, pRegistryPath);
        Assert(Status == STATUS_SUCCESS);
        if (Status == STATUS_SUCCESS)
        {
            g_VPoxUsbGlobals.pDrvObj = pDriverObject;

            pDriverObject->DriverExtension->AddDevice = vpoxUsbDdiAddDevice;

            pDriverObject->DriverUnload = vpoxUsbDdiUnload;

            pDriverObject->MajorFunction[IRP_MJ_CREATE] = vpoxUsbDispatchCreate;
            pDriverObject->MajorFunction[IRP_MJ_CLOSE] =  vpoxUsbDispatchClose;
            pDriverObject->MajorFunction[IRP_MJ_READ] = vpoxUsbDispatchRead;
            pDriverObject->MajorFunction[IRP_MJ_WRITE] = vpoxUsbDispatchWrite;
            pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = vpoxUsbDispatchDeviceControl;
            pDriverObject->MajorFunction[IRP_MJ_CLEANUP] = vpoxUsbDispatchCleanup;
            pDriverObject->MajorFunction[IRP_MJ_POWER] = vpoxUsbDispatchPower;
            pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = vpoxUsbDispatchSystemControl;
            pDriverObject->MajorFunction[IRP_MJ_PNP] = vpoxUsbDispatchPnP;

            return STATUS_SUCCESS;
        }
        vpoxUsbRtGlobalsTerm();
    }

    LogRel(("VPoxUsb::DriverEntry. failed with Status (0x%x)\n", Status));

    return Status;
}

#ifdef VPOX_STRICT
DECLHIDDEN(VOID) vpoxUsbPnPStateGbgChange(ENMVPOXUSB_PNPSTATE enmOldState, ENMVPOXUSB_PNPSTATE enmNewState)
{
    /* *ensure the state change is valid */
    switch (enmNewState)
    {
        case ENMVPOXUSB_PNPSTATE_STARTED:
            Assert(   enmOldState == ENMVPOXUSB_PNPSTATE_START_PENDING
                   || enmOldState == ENMVPOXUSB_PNPSTATE_REMOVE_PENDING
                   || enmOldState == ENMVPOXUSB_PNPSTATE_STOPPED
                   || enmOldState == ENMVPOXUSB_PNPSTATE_STOP_PENDING);
            break;
        case ENMVPOXUSB_PNPSTATE_STOP_PENDING:
            Assert(enmOldState == ENMVPOXUSB_PNPSTATE_STARTED);
            break;
        case ENMVPOXUSB_PNPSTATE_STOPPED:
            Assert(enmOldState == ENMVPOXUSB_PNPSTATE_STOP_PENDING);
            break;
        case ENMVPOXUSB_PNPSTATE_SURPRISE_REMOVED:
            Assert(enmOldState == ENMVPOXUSB_PNPSTATE_STARTED);
            break;
        case ENMVPOXUSB_PNPSTATE_REMOVE_PENDING:
            Assert(enmOldState == ENMVPOXUSB_PNPSTATE_STARTED);
            break;
        case ENMVPOXUSB_PNPSTATE_REMOVED:
            Assert(   enmOldState == ENMVPOXUSB_PNPSTATE_REMOVE_PENDING
                   || enmOldState == ENMVPOXUSB_PNPSTATE_SURPRISE_REMOVED);
            break;
        default:
            AssertFailed();
            break;
    }

}
#endif
